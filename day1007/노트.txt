**배열: 자료형이 같은 기억장소의 모임
자료형이 같은 기억장소가 많이 필요하다면 일일이 변수이름을 정해주지 않고
대표하는 이름, 자료형, 크기를 정해주어 한꺼번에 많은 변수를 확보할 수 있고
반복문을 사용해 일괄처리 할 수 있음

배열을 사용할 때는 다음과 같이 자료형, 배열이름, 배열크기를 정해주어 
배열을 선언하고 사용함

int a[];   //이 때 a는 배열의 이름, []는 배열임을 표시
a = new int[5];    //a가 int형 5개만큼 메모리를 확보하라는 뜻

*배열이라는 기호 []를 배열이름 앞에 쓸 수도 있고, 뒤에 쓸 수도 있음

한 문장으로 표현하면 > int a[] = new int[5];
		 int[] a = new int[5];


*배열의 요소가 처음부터 정해진 경우 배열을 선언함과 동시에 초기화할 수도 있음
int[] a = {10,20,30,40,50};
자동으로 배열의 길이는 초기화한 데이터의 수만큼 정해짐

*배열은 자동으로 초기값을 가짐
자료형에 따라 boolean은 false, String은 null, 정수는 0, 실수는 0.0
즉! int a; 라고 하고 초기화하지 않은 상태로 a변수를 사용할 수 없음
다음과 같이 출력하면 오류발생함 > System.out.println(a);

배열의 경우는 int[] b = new b[5]; 라고 하면
5개의 기억장소 모두 0으로 초기화됨
따라서 다음과 같은 출력문 사용가능 > System.out.println(b[0]); > 0 출력

그러나 배열을 선언하기만 하고 배열의 메모리 확보를 하기 전에는 사용할 수 없음
아직 배열이 확보되기 전이라 사용할 수 없음 > int[] k;
k[0] = 5; 라고 하면 오류발생
위에서 k를 정수형의 배열로 쓰겠다라고만 한거지 크기가 정해지지 않아서 사용할 수 없음
-----------------------------------------------------
<<다차원 배열>>
배열 안에 또 배열이 있을 수 있음!

*일차원 배열
int[] a = new int[5];

*이차원 배열
만약 5개짜리 정수형 변수가 3묶음 필요하다면 다음과 같이 사용할 수 있음
int[][] a = new int[3][5];
2차원 배열 이상을 "다차원 배열"이라고 함
5칸짜리 정수형 변수가 3줄있다 > 즉 정수형 변수가 15개 만들어짐 > 이것을 보통 행,열로 이야기함 
> 3행 5열의 이차원배열!

위의 이차원 배열을 일괄처리하려면 중첩반복문을 사용해야 함
행을 위한 반복문 안에서 열을 위한 반복문이 돌아야 함

*삼차원 배열
만약에 5칸짜리 정수형 변수가 3묶음 있고 그런것이 2장 필요하다면
다음과 같이 표현할 수 있음
int[][][] a = new int[2][3][5];
2면,3행,5열로 생각하면 이해가 쉬움!

위의 삼차원 배열을 일괄처리하려면 세개의 중첩반복문을 사용해야 함
일반적으로 특별한 경우가 아니면 삼차원배열 이상은 잘 사용하지 않음
--------------------------------------------------
*배열의 단점
자료형이 같아야 함
크기가 고정되어 있음

int[] a = new int[5]; 라고 해두면 int밖에 담을 수 없고 5개밖에 담을 수 없음
사용자가 어떤 자료형을 담을지, 몇 개를 담을지 예측하기 어려운 경우 배열을 사용하기는 불편함
이러한 배열의 단점을 보완하기 위해 자바는 "향상된 배열"인 "컬렉션 프레임워크"를 제공함
따라서 기본 자료형의 배열보다는 컬렉션 프레임워크를 사용하는 것이 더 일반적임
---------------------------------------------------
자바의 이차원배열에서는 각 행마다 열의 크기가 다를 수 있음!
int[][] a = {{1,2},{3,4,5,6},{7,8,9}};
그러면! 이거 일괄처리 어떻게 해야하나요?

for(int i=0; i<3; i++){
	for(int j=0; j<a[i].length; j++){
	}
}

자바에서는 각 행마다 열의 크기가 다를 수 있으므로 배열의 길이를 위한 속성을 사용함
2차원 배열명인 a.length는 3임 
첫번째 요소인 a[0].length는 2임 
두번째 요소인 a[1].length는 4임 
세번째 요소인 a[2].length는 3임 
----------------------------------------------------------
<기본자료형 변수와 참조자료형 변수>
기본자료형 변수는 변수자신이 값을 가지지만
참조자료형 변수는 변수자신이 값을 갖고 있지 않고 값이 있는 메모리를 참조함
int a = 10;
위 문장에서 a는 기본자료형 변수이며 변수 자신이 10이라는 값을 갖고 있음

int[] b = {10,20,30,40,50};
위 문장에서 b는 참조자료형 변수이며 변수 자신이 값을 갖고 있지 않고
값이 있는 메모리를 참조함
-----------------------------------------------------------
[메소드]
어떤 문제해결을 위한(기능을 위한) 서로 관련있는 명령어들의 집합을 메소드라고 함
어떤 일을 수행하기 위한 명령어들이 빈번하게 사용된다면 그 일을 처리하기 위한 명령어들을 모아서
메소드로 만들면 매번 똑같은 명령어를 일일이 쓰지않고 메소드 호출하여 사용할 수 있음

메소드를 만들 때는 메소드가 수행하는 일에 알맞도록 
이름을 정해주고 소괄호를 반드시 열고 닫아야 함
또, 소괄호 안에서는 그 메소드를 실행에 필요한 값을 전달받을 수 있음
메소드의 역할에 따라 값을 전달받지 않을 수도 있고 
한개 전달 받을 수도, 때에 따라 여러 개 전달받을 수도 있음
올수도있고 안올수도 있는 건 []로 표현함

실제로 메소드가 해야하는 명령어들은 중괄호{} 속에다가 써줌

메소드이름([자료형 변수명1, 자료형 변수명2...]){
	메소드가 해야할 명령어(들)
	}

이렇게 메소드를 만들어놓고 필요할 때 메소드이름을 써주면 메소드의 중괄호{}안의
명령어들이 차례로 동작하고 동작이 끝나면 메소드를 호출한 쪽으로 되돌아감

때로는 메소드{} 중간에서 다 끝나기도 전에 어떠한 상황에 따라 나머지 명령어들을 마저
동작하지 않고 되돌아가게 할 수도 있음
그때 되돌아가게 하기 위한 명령어는 return임
메소드{} 맨 끝에는 return을 쓰지 않아도 생략이 된 것임

메소드를 만들 때 메소드이름 왼쪽에 메소드의 자료형을 써주어야 함
메소드의 자료형이란 메소드는 호출문에 의해서 동작하고 
메소드의 내용이 다 끝나면 메소드를 호출한 쪽으로 되돌아감
이때 되돌아갈 때 메소드 안에서 처리된 어떠한 결과값을 갖고 되돌아갈 수도 있고
아무값도 갖지 않고 빈손으로 되돌아갈 수도 있음
만약, 되돌아갈 때 아무값도 갖지 않고 가는 경우를 "리턴값이 없다"고 하고
결과값을 갖고가는 경우를 "리턴값이 있다"고 함
리턴값이 있는 경우라면 메소드 이름 왼쪽에 리턴값의 자료형을 써줌
리턴값이 없는 경우에는 void라고 써줌

리턴값이 없는 경우:
void 메소드이름(){
      return;
}

리턴값이 있는 경우:
int 메소드이름(){ 
sum = 0;
어쩌구저쩌구...

return sum;
}

*메소드를 호출한 결과값이 int임
이 결과값을 메소드 호출한 쪽에서 변수에 담아 다른 일 처리에 사용할 수 있음
int 변수명 = 메소드이름();
------------------------------------
메소드를 만들기 위해서는 그 메소드를 사용하는 클래스 안에서 메소드를 만들 수도 있고
별도의 메소드를 포함하는 클래스를 만들어 사용할 수도 있음

우리가 어떠한 클래스 안에 메소드를 만들어놓고 그 메소드를 사용하려면 마치
Scanner의 next메소드를 사용하거나 Random의 next를 사용하거나
Date의 getYear를 사용할 때처럼 반드시 객체를 생성해놓고 그 객체를 통해서
메소드를 사용할 수 있음

그런데 만약 System.out.println()처럼 객체없이도 사용하게 하려면
메소드이름 왼쪽에 static을 붙이면 객체생성 하지 않고
클래스이름.메소드이름()으로 바로 사용할 수도 있음
-------------------------------------
만약 구구단을 출력할 일이 많다면 다음과 같이 몇단을 출력할 것인지를 변수로 전달받아
해당하는 구구단을 출력하는 메소드를 만들 수 있다.
MyUtil라는 클래스를 만들고 그 클래스 안에 dan을 매개변수로 전달받아
구구단을 출력하는 gugudan메소드를 만들어보자.
//메소드이름 gugudan
//메소드 실행에 필요한 값을 전달받는 변수(매개변수) int dan
//{}안의 내용: 실제 메소드가 하는 일
//return이 없네? 메소드이름 앞에 void 붙이기

class MyUtil{
	void gugudan(int dan){
		System.out.printf("***%단***\n",dan);
		for(int i=1; i<=9; i++){
		System.out.printf("%d*%d=%d\n",dan,i,dan*i)}
		}
	}
}

//메소드를 사용하는 클래스를 따로 만들겠음
**사용하려는 메소드의 매개변수의 자료형과 전달하는 값의 자료형이 서로 일치해야 함
사용하려는 메소드의 매개변수의 개수와 호출할 때 전달하는 매개변수의 개수가 서로 일치해야 함
하나의 파일에 두개이상의 클래스를 만들 때는 메인메소드를 포함하는 클래스이름으로 파일명 저장해야함 

class MethodTest1
	public static void main(String []args){
		MyUtil mu = new MyUtil();
		mu.gugudan();
	
		
		}
	}
----------------------------------
<<배열을 매개변수로 갖는 메소드>>
메소드자료형 메소드이름(자료형[] 배열이름){
}
예를 들어 int[] a = {1,2,3,4,5};
라는 배열이 있고 이것을 매개변수로 받은 메소드를 만들어보면
void pro(int[] data){
}
이 메소드를 호출하려면 pro(a)라고 메소드호출 시에 배열이름을 전달하면 됨
이 때 호출하는 배열이름과 메소드의 매개변수의 이름은 같아도 상관없고 달라도 상관없음 













