/*정렬: 값을 순서대로 표현하는 것을 말함
-오름차순 정렬: 값이 작은것부터 먼저 오게함
-내림차순 정렬: 값이 큰것부터 먼저 오게함

int[] data = {5,2,3,9,1};
만약 위와 같이 배열의 요소가 5개로 구성되어 있다면
오름차순 정렬이 된 후에는 다음과 같아야 함
{1,2,3,5,9};

정렬하기 위해서는 배열의 각 자리에 와야 할 값을 차례로 찾아야 함
위와 같이 배열의 원소가 5개라면
0번째 자리에는 5개 중에 가장 작은 값을 찾아 놓아야 함      //0번째 자리에 올 수는 1
0번째 자리의 값을 찾기 위해서는 1번째부터 4번째까지 0번째의 값과 비교하는 값이
0번째의 값보다 더 작으면 서로 맞바꾸어야 함
즉 0번째에 와야 할 값을 찾기 위해서는 1번째부터 모든 배열의 원소를 비교하여 찾아야 함
0번째 와야 할 값을 찾았다면 그 다음 1번째 와야 할 값을 찾아야 함
1번째 와야 할 값을 찾기 위해서는 이미 자리를 잡은 0번째와는 비교할 필요가 없고
2번째부터 4번째까지 모든 배열의 원소를 1번째와 비교하는 값이
1번째의 값보다 더 작으면 서로 맞바꾸어야 함
즉 정렬할 때는 중첩 반복문을 써야 하며 i번째 와야 할 값을 찾을 때        //i=0번째 인덱스라고 가정
비교하는 j는 i+1부터 배열의 길이만큼 모두 비교하여 크기가 맞지 않으면     //1번째 인덱스=i+1 /배열의길이5
서로 i번째 원소와 j번째 원소를 서로 맞바꾸어 줌
*/

//연습) 위 설명글 배열의 원소를 오름차순 정렬하여 출력해보기

class SortArray 
{
	public static void main(String[] args) 
	{
		int[] data = {5,2,3,9,1};
		//오름차순 정렬: {1,2,3,5,9};
		for(int i=0; i<data.length; i++){          //0번째 인덱스 5부터 배열의길이 5까지 반복   
		
			for(int j=i+1; j<data.length; j++){    //i랑 비교할j=i+1(=0+1) > 1번째 인덱스부터라는 뜻!(2)
				if(data[j] < data[i]){             //작으니까 서로 바꿔야겠네? 왜냐면 지금 오름차순 정렬이니까 작은 수부터 찾아야하잖아?
					int temp = data[i];            //temp임시변수를 새로 만들어서 j보다 큰 수 i를 잠시 넣자!
					data[i] = data[j];             //작은 수j를 i자리에 넣어서 앞으로 땡겨!(왼쪽으로)
					data[j] = temp;                //temp에 있는 큰 수i를 j에 넣기
				}
				
			} 
		}
			System.out.println("***오름차순 정렬 결과***");
			for(int i=0; i<data.length; i++){
				System.out.print(data[i] + " ");
		}
	}
}

/*
1)  2 < 5 ? ㅇㅇ
2) temp만들었어 > i랑 j랑 맞바꾸기(작은 게 앞으로 가게끔)
3) j++
4) 3 < 2 ? ㄴㄴ
5) j++
6) 9 < 3? ㄴㄴ
7) j++
8) 2 < 3? ㅇㅇ
9) 맞바꾸기
*/